{"version":3,"file":"static/js/907.a3bf73db.chunk.js","mappings":"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","sources":["../node_modules/react-query/es/core/utils.js","../node_modules/react-query/es/core/notifyManager.js","../node_modules/react-query/es/react/reactBatchedUpdates.js","../node_modules/react-query/es/react/setBatchUpdatesFn.js","../node_modules/react-query/es/core/logger.js","../node_modules/react-query/es/react/logger.js","../node_modules/react-query/es/react/setLogger.js","../node_modules/react-query/es/core/subscribable.js","../node_modules/react-query/es/core/focusManager.js","../node_modules/react-query/es/core/retryer.js","../node_modules/react-query/es/core/queryObserver.js","../node_modules/react-query/es/react/QueryErrorResetBoundary.js","../node_modules/react-query/es/react/QueryClientProvider.js","../node_modules/react-query/es/react/useQuery.js","../node_modules/react-query/es/react/useBaseQuery.js","../node_modules/react-query/es/react/utils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n// TYPES\n// UTILS\nexport var isServer = typeof window === 'undefined';\nexport function noop() {\n  return undefined;\n}\nexport function functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nexport function isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nexport function ensureQueryKeyArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nexport function difference(array1, array2) {\n  return array1.filter(function (x) {\n    return array2.indexOf(x) === -1;\n  });\n}\nexport function replaceAt(array, index, value) {\n  var copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nexport function timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nexport function parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return _extends({}, arg3, {\n      queryKey: arg1,\n      queryFn: arg2\n    });\n  }\n\n  return _extends({}, arg2, {\n    queryKey: arg1\n  });\n}\nexport function parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return _extends({}, arg3, {\n        mutationKey: arg1,\n        mutationFn: arg2\n      });\n    }\n\n    return _extends({}, arg2, {\n      mutationKey: arg1\n    });\n  }\n\n  if (typeof arg1 === 'function') {\n    return _extends({}, arg2, {\n      mutationFn: arg1\n    });\n  }\n\n  return _extends({}, arg1);\n}\nexport function parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [_extends({}, arg2, {\n    queryKey: arg1\n  }), arg3] : [arg1 || {}, arg2];\n}\nexport function parseMutationFilterArgs(arg1, arg2) {\n  return isQueryKey(arg1) ? _extends({}, arg2, {\n    mutationKey: arg1\n  }) : arg1;\n}\nexport function mapQueryStatusFilter(active, inactive) {\n  if (active === true && inactive === true || active == null && inactive == null) {\n    return 'all';\n  } else if (active === false && inactive === false) {\n    return 'none';\n  } else {\n    // At this point, active|inactive can only be true|false or false|true\n    // so, when only one value is provided, the missing one has to be the negated value\n    var isActive = active != null ? active : !inactive;\n    return isActive ? 'active' : 'inactive';\n  }\n}\nexport function matchQuery(filters, query) {\n  var active = filters.active,\n      exact = filters.exact,\n      fetching = filters.fetching,\n      inactive = filters.inactive,\n      predicate = filters.predicate,\n      queryKey = filters.queryKey,\n      stale = filters.stale;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  var queryStatusFilter = mapQueryStatusFilter(active, inactive);\n\n  if (queryStatusFilter === 'none') {\n    return false;\n  } else if (queryStatusFilter !== 'all') {\n    var isActive = query.isActive();\n\n    if (queryStatusFilter === 'active' && !isActive) {\n      return false;\n    }\n\n    if (queryStatusFilter === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetching === 'boolean' && query.isFetching() !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nexport function matchMutation(filters, mutation) {\n  var exact = filters.exact,\n      fetching = filters.fetching,\n      predicate = filters.predicate,\n      mutationKey = filters.mutationKey;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nexport function hashQueryKeyByOptions(queryKey, options) {\n  var hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n */\n\nexport function hashQueryKey(queryKey) {\n  var asArray = ensureQueryKeyArray(queryKey);\n  return stableValueHash(asArray);\n}\n/**\n * Hashes the value into a stable hash.\n */\n\nexport function stableValueHash(value) {\n  return JSON.stringify(value, function (_, val) {\n    return isPlainObject(val) ? Object.keys(val).sort().reduce(function (result, key) {\n      result[key] = val[key];\n      return result;\n    }, {}) : val;\n  });\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nexport function partialMatchKey(a, b) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nexport function partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(function (key) {\n      return !partialDeepEqual(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nexport function replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  var array = Array.isArray(a) && Array.isArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    var aSize = array ? a.length : Object.keys(a).length;\n    var bItems = array ? b : Object.keys(b);\n    var bSize = bItems.length;\n    var copy = array ? [] : {};\n    var equalItems = 0;\n\n    for (var i = 0; i < bSize; i++) {\n      var key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nexport function shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (var key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nexport function isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  var ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  var prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport function isQueryKey(value) {\n  return typeof value === 'string' || Array.isArray(value);\n}\nexport function isError(value) {\n  return value instanceof Error;\n}\nexport function sleep(timeout) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nexport function scheduleMicrotask(callback) {\n  Promise.resolve().then(callback).catch(function (error) {\n    return setTimeout(function () {\n      throw error;\n    });\n  });\n}\nexport function getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}","import { scheduleMicrotask } from './utils'; // TYPES\n\n// CLASS\nexport var NotifyManager = /*#__PURE__*/function () {\n  function NotifyManager() {\n    this.queue = [];\n    this.transactions = 0;\n\n    this.notifyFn = function (callback) {\n      callback();\n    };\n\n    this.batchNotifyFn = function (callback) {\n      callback();\n    };\n  }\n\n  var _proto = NotifyManager.prototype;\n\n  _proto.batch = function batch(callback) {\n    var result;\n    this.transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      this.transactions--;\n\n      if (!this.transactions) {\n        this.flush();\n      }\n    }\n\n    return result;\n  };\n\n  _proto.schedule = function schedule(callback) {\n    var _this = this;\n\n    if (this.transactions) {\n      this.queue.push(callback);\n    } else {\n      scheduleMicrotask(function () {\n        _this.notifyFn(callback);\n      });\n    }\n  }\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  ;\n\n  _proto.batchCalls = function batchCalls(callback) {\n    var _this2 = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this2.schedule(function () {\n        callback.apply(void 0, args);\n      });\n    };\n  };\n\n  _proto.flush = function flush() {\n    var _this3 = this;\n\n    var queue = this.queue;\n    this.queue = [];\n\n    if (queue.length) {\n      scheduleMicrotask(function () {\n        _this3.batchNotifyFn(function () {\n          queue.forEach(function (callback) {\n            _this3.notifyFn(callback);\n          });\n        });\n      });\n    }\n  }\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  ;\n\n  _proto.setNotifyFunction = function setNotifyFunction(fn) {\n    this.notifyFn = fn;\n  }\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  ;\n\n  _proto.setBatchNotifyFunction = function setBatchNotifyFunction(fn) {\n    this.batchNotifyFn = fn;\n  };\n\n  return NotifyManager;\n}(); // SINGLETON\n\nexport var notifyManager = new NotifyManager();","import ReactDOM from 'react-dom';\nexport var unstable_batchedUpdates = ReactDOM.unstable_batchedUpdates;","import { notifyManager } from '../core';\nimport { unstable_batchedUpdates } from './reactBatchedUpdates';\nnotifyManager.setBatchNotifyFunction(unstable_batchedUpdates);","// TYPES\n// FUNCTIONS\nvar logger = console;\nexport function getLogger() {\n  return logger;\n}\nexport function setLogger(newLogger) {\n  logger = newLogger;\n}","export var logger = console;","import { setLogger } from '../core';\nimport { logger } from './logger';\nsetLogger(logger);","export var Subscribable = /*#__PURE__*/function () {\n  function Subscribable() {\n    this.listeners = [];\n  }\n\n  var _proto = Subscribable.prototype;\n\n  _proto.subscribe = function subscribe(listener) {\n    var _this = this;\n\n    var callback = listener || function () {\n      return undefined;\n    };\n\n    this.listeners.push(callback);\n    this.onSubscribe();\n    return function () {\n      _this.listeners = _this.listeners.filter(function (x) {\n        return x !== callback;\n      });\n\n      _this.onUnsubscribe();\n    };\n  };\n\n  _proto.hasListeners = function hasListeners() {\n    return this.listeners.length > 0;\n  };\n\n  _proto.onSubscribe = function onSubscribe() {// Do nothing\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {// Do nothing\n  };\n\n  return Subscribable;\n}();","import _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport { Subscribable } from './subscribable';\nimport { isServer } from './utils';\nexport var FocusManager = /*#__PURE__*/function (_Subscribable) {\n  _inheritsLoose(FocusManager, _Subscribable);\n\n  function FocusManager() {\n    var _this;\n\n    _this = _Subscribable.call(this) || this;\n\n    _this.setup = function (onFocus) {\n      var _window;\n\n      if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {\n        var listener = function listener() {\n          return onFocus();\n        }; // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return function () {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = FocusManager.prototype;\n\n  _proto.onSubscribe = function onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  };\n\n  _proto.setEventListener = function setEventListener(setup) {\n    var _this$cleanup2,\n        _this2 = this;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(function (focused) {\n      if (typeof focused === 'boolean') {\n        _this2.setFocused(focused);\n      } else {\n        _this2.onFocus();\n      }\n    });\n  };\n\n  _proto.setFocused = function setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  };\n\n  _proto.onFocus = function onFocus() {\n    this.listeners.forEach(function (listener) {\n      listener();\n    });\n  };\n\n  _proto.isFocused = function isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  };\n\n  return FocusManager;\n}(Subscribable);\nexport var focusManager = new FocusManager();","import { focusManager } from './focusManager';\nimport { onlineManager } from './onlineManager';\nimport { sleep } from './utils';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\n\nexport function isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\nexport var CancelledError = function CancelledError(options) {\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n};\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n} // CLASS\n\nexport var Retryer = function Retryer(config) {\n  var _this = this;\n\n  var cancelRetry = false;\n  var cancelFn;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n  this.abort = config.abort;\n\n  this.cancel = function (cancelOptions) {\n    return cancelFn == null ? void 0 : cancelFn(cancelOptions);\n  };\n\n  this.cancelRetry = function () {\n    cancelRetry = true;\n  };\n\n  this.continueRetry = function () {\n    cancelRetry = false;\n  };\n\n  this.continue = function () {\n    return continueFn == null ? void 0 : continueFn();\n  };\n\n  this.failureCount = 0;\n  this.isPaused = false;\n  this.isResolved = false;\n  this.isTransportCancelable = false;\n  this.promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var resolve = function resolve(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  var reject = function reject(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = continueResolve;\n      _this.isPaused = true;\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n      _this.isPaused = false;\n      config.onContinue == null ? void 0 : config.onContinue();\n    });\n  }; // Create loop function\n\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (_this.isResolved) {\n      return;\n    }\n\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    } // Create callback to cancel this fetch\n\n\n    cancelFn = function cancelFn(cancelOptions) {\n      if (!_this.isResolved) {\n        reject(new CancelledError(cancelOptions));\n        _this.abort == null ? void 0 : _this.abort(); // Cancel transport if supported\n\n        if (isCancelable(promiseOrValue)) {\n          try {\n            promiseOrValue.cancel();\n          } catch (_unused) {}\n        }\n      }\n    }; // Check if the transport layer support cancellation\n\n\n    _this.isTransportCancelable = isCancelable(promiseOrValue);\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (_this.isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === 'function' ? retryDelay(_this.failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === 'number' && _this.failureCount < retry || typeof retry === 'function' && retry(_this.failureCount, error);\n\n      if (cancelRetry || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      _this.failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(_this.failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n          return pause();\n        }\n      }).then(function () {\n        if (cancelRetry) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  run();\n};","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport { isServer, isValidTimeout, noop, replaceEqualDeep, shallowEqualObjects, timeUntilStale } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { focusManager } from './focusManager';\nimport { Subscribable } from './subscribable';\nimport { getLogger } from './logger';\nimport { isCancelledError } from './retryer';\nexport var QueryObserver = /*#__PURE__*/function (_Subscribable) {\n  _inheritsLoose(QueryObserver, _Subscribable);\n\n  function QueryObserver(client, options) {\n    var _this;\n\n    _this = _Subscribable.call(this) || this;\n    _this.client = client;\n    _this.options = options;\n    _this.trackedProps = [];\n    _this.selectError = null;\n\n    _this.bindMethods();\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.bindMethods = function bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  };\n\n  _proto.onSubscribe = function onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  };\n\n  _proto.shouldFetchOnReconnect = function shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  };\n\n  _proto.shouldFetchOnWindowFocus = function shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  };\n\n  _proto.destroy = function destroy() {\n    this.listeners = [];\n    this.clearTimers();\n    this.currentQuery.removeObserver(this);\n  };\n\n  _proto.setOptions = function setOptions(options, notifyOptions) {\n    var prevOptions = this.options;\n    var prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryObserverOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    var mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    var nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  };\n\n  _proto.getOptimisticResult = function getOptimisticResult(options) {\n    var defaultedOptions = this.client.defaultQueryObserverOptions(options);\n    var query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    return this.createResult(query, defaultedOptions);\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  };\n\n  _proto.trackResult = function trackResult(result, defaultedOptions) {\n    var _this2 = this;\n\n    var trackedResult = {};\n\n    var trackProp = function trackProp(key) {\n      if (!_this2.trackedProps.includes(key)) {\n        _this2.trackedProps.push(key);\n      }\n    };\n\n    Object.keys(result).forEach(function (key) {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: function get() {\n          trackProp(key);\n          return result[key];\n        }\n      });\n    });\n\n    if (defaultedOptions.useErrorBoundary || defaultedOptions.suspense) {\n      trackProp('error');\n    }\n\n    return trackedResult;\n  };\n\n  _proto.getNextResult = function getNextResult(options) {\n    var _this3 = this;\n\n    return new Promise(function (resolve, reject) {\n      var unsubscribe = _this3.subscribe(function (result) {\n        if (!result.isFetching) {\n          unsubscribe();\n\n          if (result.isError && (options == null ? void 0 : options.throwOnError)) {\n            reject(result.error);\n          } else {\n            resolve(result);\n          }\n        }\n      });\n    });\n  };\n\n  _proto.getCurrentQuery = function getCurrentQuery() {\n    return this.currentQuery;\n  };\n\n  _proto.remove = function remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  };\n\n  _proto.refetch = function refetch(options) {\n    return this.fetch(_extends({}, options, {\n      meta: {\n        refetchPage: options == null ? void 0 : options.refetchPage\n      }\n    }));\n  };\n\n  _proto.fetchOptimistic = function fetchOptimistic(options) {\n    var _this4 = this;\n\n    var defaultedOptions = this.client.defaultQueryObserverOptions(options);\n    var query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    return query.fetch().then(function () {\n      return _this4.createResult(query, defaultedOptions);\n    });\n  };\n\n  _proto.fetch = function fetch(fetchOptions) {\n    var _this5 = this;\n\n    return this.executeFetch(fetchOptions).then(function () {\n      _this5.updateResult();\n\n      return _this5.currentResult;\n    });\n  };\n\n  _proto.executeFetch = function executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    var promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  };\n\n  _proto.updateStaleTimeout = function updateStaleTimeout() {\n    var _this6 = this;\n\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    var timeout = time + 1;\n    this.staleTimeoutId = setTimeout(function () {\n      if (!_this6.currentResult.isStale) {\n        _this6.updateResult();\n      }\n    }, timeout);\n  };\n\n  _proto.computeRefetchInterval = function computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval(nextInterval) {\n    var _this7 = this;\n\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this7.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        _this7.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  };\n\n  _proto.updateTimers = function updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  };\n\n  _proto.clearTimers = function clearTimers() {\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  };\n\n  _proto.createResult = function createResult(query, options) {\n    var prevQuery = this.currentQuery;\n    var prevOptions = this.options;\n    var prevResult = this.currentResult;\n    var prevResultState = this.currentResultState;\n    var prevResultOptions = this.currentResultOptions;\n    var queryChange = query !== prevQuery;\n    var queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    var prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    var state = query.state;\n    var dataUpdatedAt = state.dataUpdatedAt,\n        error = state.error,\n        errorUpdatedAt = state.errorUpdatedAt,\n        isFetching = state.isFetching,\n        status = state.status;\n    var isPreviousData = false;\n    var isPlaceholderData = false;\n    var data; // Optimistically set result in fetching state if needed\n\n    if (options.optimisticResults) {\n      var mounted = this.hasListeners();\n      var fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      var fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        isFetching = true;\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && (prevQueryResult == null ? void 0 : prevQueryResult.isSuccess) && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n        // Memoize select result\n        if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n          data = this.selectResult;\n        } else {\n          try {\n            this.selectFn = options.select;\n            data = options.select(state.data);\n\n            if (options.structuralSharing !== false) {\n              data = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, data);\n            }\n\n            this.selectResult = data;\n            this.selectError = null;\n          } catch (selectError) {\n            getLogger().error(selectError);\n            this.selectError = selectError;\n          }\n        }\n      } // Use query data\n      else {\n          data = state.data;\n        } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && (status === 'loading' || status === 'idle')) {\n      var placeholderData; // Memoize placeholder data\n\n      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n\n            if (options.structuralSharing !== false) {\n              placeholderData = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, placeholderData);\n            }\n\n            this.selectError = null;\n          } catch (selectError) {\n            getLogger().error(selectError);\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    var result = {\n      status: status,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      isIdle: status === 'idle',\n      data: data,\n      dataUpdatedAt: dataUpdatedAt,\n      error: error,\n      errorUpdatedAt: errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData: isPlaceholderData,\n      isPreviousData: isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  };\n\n  _proto.shouldNotifyListeners = function shouldNotifyListeners(result, prevResult) {\n    if (!prevResult) {\n      return true;\n    }\n\n    var _this$options = this.options,\n        notifyOnChangeProps = _this$options.notifyOnChangeProps,\n        notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;\n\n    if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {\n      return true;\n    }\n\n    if (notifyOnChangeProps === 'tracked' && !this.trackedProps.length) {\n      return true;\n    }\n\n    var includedProps = notifyOnChangeProps === 'tracked' ? this.trackedProps : notifyOnChangeProps;\n    return Object.keys(result).some(function (key) {\n      var typedKey = key;\n      var changed = result[typedKey] !== prevResult[typedKey];\n      var isIncluded = includedProps == null ? void 0 : includedProps.some(function (x) {\n        return x === key;\n      });\n      var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function (x) {\n        return x === key;\n      });\n      return changed && !isExcluded && (!includedProps || isIncluded);\n    });\n  };\n\n  _proto.updateResult = function updateResult(notifyOptions) {\n    var prevResult = this.currentResult;\n    this.currentResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify if something has changed\n\n    if (shallowEqualObjects(this.currentResult, prevResult)) {\n      return;\n    } // Determine which callbacks to trigger\n\n\n    var defaultNotifyOptions = {\n      cache: true\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && this.shouldNotifyListeners(this.currentResult, prevResult)) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify(_extends({}, defaultNotifyOptions, notifyOptions));\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    var prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(action) {\n    var notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  };\n\n  _proto.notify = function notify(notifyOptions) {\n    var _this8 = this;\n\n    notifyManager.batch(function () {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        _this8.options.onSuccess == null ? void 0 : _this8.options.onSuccess(_this8.currentResult.data);\n        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(_this8.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        _this8.options.onError == null ? void 0 : _this8.options.onError(_this8.currentResult.error);\n        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(undefined, _this8.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        _this8.listeners.forEach(function (listener) {\n          listener(_this8.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        _this8.client.getQueryCache().notify({\n          query: _this8.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  };\n\n  return QueryObserver;\n}(Subscribable);\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    var value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}","import React from 'react'; // CONTEXT\n\nfunction createValue() {\n  var _isReset = false;\n  return {\n    clearReset: function clearReset() {\n      _isReset = false;\n    },\n    reset: function reset() {\n      _isReset = true;\n    },\n    isReset: function isReset() {\n      return _isReset;\n    }\n  };\n}\n\nvar QueryErrorResetBoundaryContext = /*#__PURE__*/React.createContext(createValue()); // HOOK\n\nexport var useQueryErrorResetBoundary = function useQueryErrorResetBoundary() {\n  return React.useContext(QueryErrorResetBoundaryContext);\n}; // COMPONENT\n\nexport var QueryErrorResetBoundary = function QueryErrorResetBoundary(_ref) {\n  var children = _ref.children;\n  var value = React.useMemo(function () {\n    return createValue();\n  }, []);\n  return /*#__PURE__*/React.createElement(QueryErrorResetBoundaryContext.Provider, {\n    value: value\n  }, typeof children === 'function' ? children(value) : children);\n};","import React from 'react';\nvar defaultContext = /*#__PURE__*/React.createContext(undefined);\nvar QueryClientSharingContext = /*#__PURE__*/React.createContext(false); // if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\n\nfunction getQueryClientContext(contextSharing) {\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext;\n    }\n\n    return window.ReactQueryClientContext;\n  }\n\n  return defaultContext;\n}\n\nexport var useQueryClient = function useQueryClient() {\n  var queryClient = React.useContext(getQueryClientContext(React.useContext(QueryClientSharingContext)));\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one');\n  }\n\n  return queryClient;\n};\nexport var QueryClientProvider = function QueryClientProvider(_ref) {\n  var client = _ref.client,\n      _ref$contextSharing = _ref.contextSharing,\n      contextSharing = _ref$contextSharing === void 0 ? false : _ref$contextSharing,\n      children = _ref.children;\n  React.useEffect(function () {\n    client.mount();\n    return function () {\n      client.unmount();\n    };\n  }, [client]);\n  var Context = getQueryClientContext(contextSharing);\n  return /*#__PURE__*/React.createElement(QueryClientSharingContext.Provider, {\n    value: contextSharing\n  }, /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, children));\n};","import { QueryObserver } from '../core';\nimport { parseQueryArgs } from '../core/utils';\nimport { useBaseQuery } from './useBaseQuery'; // HOOK\n\nexport function useQuery(arg1, arg2, arg3) {\n  var parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  return useBaseQuery(parsedOptions, QueryObserver);\n}","import React from 'react';\nimport { notifyManager } from '../core/notifyManager';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary';\nimport { useQueryClient } from './QueryClientProvider';\nimport { shouldThrowError } from './utils';\nexport function useBaseQuery(options, Observer) {\n  var mountedRef = React.useRef(false);\n\n  var _React$useState = React.useState(0),\n      forceUpdate = _React$useState[1];\n\n  var queryClient = useQueryClient();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = queryClient.defaultQueryObserverOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions.optimisticResults = true; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    } // Set cache time to 1 if the option has been set to 0\n    // when using suspense to prevent infinite loop of fetches\n\n\n    if (defaultedOptions.cacheTime === 0) {\n      defaultedOptions.cacheTime = 1;\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n\n  var _React$useState2 = React.useState(function () {\n    return new Observer(queryClient, defaultedOptions);\n  }),\n      observer = _React$useState2[0];\n\n  var result = observer.getOptimisticResult(defaultedOptions);\n  React.useEffect(function () {\n    mountedRef.current = true;\n    errorResetBoundary.clearReset();\n    var unsubscribe = observer.subscribe(notifyManager.batchCalls(function () {\n      if (mountedRef.current) {\n        forceUpdate(function (x) {\n          return x + 1;\n        });\n      }\n    })); // Update result to make sure we did not miss any query updates\n    // between creating the observer and subscribing to it.\n\n    observer.updateResult();\n    return function () {\n      mountedRef.current = false;\n      unsubscribe();\n    };\n  }, [errorResetBoundary, observer]);\n  React.useEffect(function () {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (defaultedOptions.suspense && result.isLoading) {\n    throw observer.fetchOptimistic(defaultedOptions).then(function (_ref) {\n      var data = _ref.data;\n      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n    }).catch(function (error) {\n      errorResetBoundary.clearReset();\n      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n    });\n  } // Handle error boundary\n\n\n  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.suspense, defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  if (defaultedOptions.notifyOnChangeProps === 'tracked') {\n    result = observer.trackResult(result, defaultedOptions);\n  }\n\n  return result;\n}","export function shouldThrowError(suspense, _useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary.apply(void 0, params);\n  } // Allow useErrorBoundary to override suspense's throwing behavior\n\n\n  if (typeof _useErrorBoundary === 'boolean') return _useErrorBoundary; // If suspense is enabled default to throwing errors\n\n  return !!suspense;\n}"],"names":["isServer","window","noop","isValidTimeout","value","Infinity","replaceEqualDeep","a","b","array","Array","isArray","isPlainObject","aSize","length","Object","keys","bItems","bSize","copy","equalItems","i","key","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","isQueryKey","scheduleMicrotask","callback","Promise","resolve","then","catch","error","setTimeout","notifyManager","NotifyManager","this","queue","transactions","notifyFn","batchNotifyFn","_proto","batch","result","flush","schedule","_this","push","batchCalls","_this2","_len","arguments","args","_key","apply","_this3","forEach","setNotifyFunction","fn","setBatchNotifyFunction","unstable_batchedUpdates","ReactDOM","logger","console","getLogger","Subscribable","listeners","subscribe","listener","onSubscribe","filter","x","onUnsubscribe","hasListeners","focusManager","_Subscribable","FocusManager","setup","onFocus","_window","addEventListener","removeEventListener","_inheritsLoose","cleanup","setEventListener","_this$cleanup","undefined","_this$cleanup2","focused","setFocused","isFocused","document","includes","visibilityState","CancelledError","options","revert","silent","QueryObserver","client","trackedProps","selectError","bindMethods","setOptions","remove","bind","refetch","currentQuery","addObserver","shouldFetchOnMount","executeFetch","updateTimers","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","clearTimers","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryObserverOptions","enabled","Error","queryKey","updateQuery","mounted","shouldFetchOptionally","updateResult","staleTime","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","defaultedOptions","query","getQueryCache","build","createResult","getCurrentResult","currentResult","trackResult","trackedResult","trackProp","defineProperty","configurable","enumerable","get","useErrorBoundary","suspense","getNextResult","reject","unsubscribe","isFetching","isError","throwOnError","getCurrentQuery","fetch","_extends","meta","refetchPage","fetchOptimistic","_this4","fetchOptions","_this5","promise","_this6","clearStaleTimeout","isStale","updatedAt","timeout","dataUpdatedAt","Math","max","Date","now","staleTimeoutId","_this$options$refetch","refetchInterval","data","nextInterval","_this7","clearRefetchInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearTimeout","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","state","currentQueryInitialState","prevQueryResult","previousQueryResult","errorUpdatedAt","status","isPreviousData","isPlaceholderData","optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","dataUpdateCount","isSuccess","select","selectFn","selectResult","structuralSharing","placeholderData","isLoading","isIdle","failureCount","fetchFailureCount","errorUpdateCount","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","shouldNotifyListeners","_this$options","notifyOnChangeProps","notifyOnChangePropsExclusions","includedProps","some","typedKey","changed","isIncluded","isExcluded","shallowEqualObjects","defaultNotifyOptions","cache","notify","onQueryUpdate","action","type","onSuccess","onError","_this8","onSettled","retryOnMount","shouldLoadOnMount","refetchOnMount","field","isStaleByTime","createValue","_isReset","clearReset","reset","isReset","QueryErrorResetBoundaryContext","React","useQueryErrorResetBoundary","defaultContext","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","useQuery","arg1","arg2","arg3","parsedOptions","queryFn","parseQueryArgs","Observer","mountedRef","forceUpdate","errorResetBoundary","cacheTime","_useErrorBoundary","params","observer","current","_ref","useBaseQuery"],"sourceRoot":""}